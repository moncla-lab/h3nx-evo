from Bio import Phylo
import json
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('--treesort_tree', type=str, required=True, help='path to treesort .tre output')
parser.add_argument('--output', type=str, required=True, help='path to output node data json')
args = parser.parse_args()

'''iteratively traverse the tree, starting at a given node
at each node or tip, add reassortment status (node.comment) to a dict'''
def find_reassortment(node, rea_dict, parent_name = None):
# if the node is named (i.e., it was not generated by forced bifurcation)
    if node.name:
        name = node.name.split("|")[0]
        # add the node's comment to the dict
        rea_dict[name] = [node.comment]
        # and set the new parent name
        parent_name = name
    # if not, the node was generated by forced bifurcation
    else:
        # if so, add the node's comment to the dict under the most recent named parental node (i.e., the node that was bifurcated)
        rea_dict[parent_name].append(node.comment)
    # iterate through the node's children and repeat
    children = node.clades
    for child in children:
        find_reassortment(child, rea_dict, parent_name)

# parse the treesort .tre file
# due to the formatting, there are additional 'trees' parsed from this file
# need to pull out the 'correct' tree from this list
tree = list(Phylo.parse(args.treesort_tree, 'newick'))

# the desired tree will be the one with children clades,
# so can pick out the tree with the most clades descended from the root
tree = sorted(tree, key=lambda x:len(x.root.clades), reverse=True)[0]

# initialize dict and run the find_reassortment function starting at the root
rea_dict = {}
find_reassortment(tree.root, rea_dict)

# initialize a 'cleaned' dict to properly format node_data
cleaned_rea_dict = {}
branch_dict = {}
segments = ["PB2", "PB1", "PA", "HA", "NP", "NA", "MP", "NS"]

for k,v in rea_dict.items():
    # check if the comment for each node/tip (or any of the nodes generated by forced bifurcation that are mapped to the parental node) contains 'is_reassorted=1'
    if any('is_reassorted=1' in vv for vv in v):
        # if so, set its reassortment status as 'True'
        cleaned_rea_dict[k] = {'Reassorted': 'True', 'Reassorted Segments': set()}
        # and iterate through the comments to determine which segments were reassorted
        for vv in v:
            for segment in segments:
                if segment in vv:
                    # if the segment name is in the comment, add it to the reassorted segments set
                    cleaned_rea_dict[k]['Reassorted Segments'].add(segment)
        # convert reassorted segments from a set of segments
        # to a string formatted as '{n_segments_reassorted} ({reassorted_segment1}, {reassorted_segment2}, ...)'
        cleaned_rea_dict[k]['Reassorted Segments'] = str(len(cleaned_rea_dict[k]['Reassorted Segments']))+' ('+', '.join(sorted(cleaned_rea_dict[k]['Reassorted Segments']))+')'
        branch_dict[k] = {'labels':{'Reassorted Segments':cleaned_rea_dict[k]['Reassorted Segments']}}
    else:
        # if not, set reassortment status as 'False'
        cleaned_rea_dict[k] = {'Reassorted': 'False'}
        
# format for auspice node_date
out_dict = {'nodes': cleaned_rea_dict, 'branches':branch_dict}

# export as json
with open(args.output, 'w') as f:
    json.dump(out_dict, f)