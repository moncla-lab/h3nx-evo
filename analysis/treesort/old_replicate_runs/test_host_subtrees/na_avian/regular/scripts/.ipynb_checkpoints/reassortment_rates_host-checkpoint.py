#HA
import statistics
import numpy as np
from scipy.optimize import minimize, LinearConstraint
import warnings

def likelihood_binary(x, rea_events, edge_lengths):
    func = 0
    if x < 1e-10:
        return np.inf
    for i in range(len(rea_events)):
        if edge_lengths[i] > 0:
            if rea_events[i] > 0:
                with warnings.catch_warnings():
                    warnings.filterwarnings('error')
                    try:
                        func -= np.log(1 - np.exp(-1 * x * edge_lengths[i]))
                    except Warning:
                        # print(x)
                        func += np.inf
            else:
                func -= (-1 * x * edge_lengths[i])
        elif rea_events[i] > 0:
            pass
    return func
    
def top_1(tree):

    branch_lengths = {}

    for k in tree.Objects:
        if k.is_node():
            branch_lengths[k.traits["label"]] = k.length
        if k.is_leaf():
            branch_lengths[k.name] = k.length

    threshold = sorted(branch_lengths.values(), reverse=True)[int(0.01 * len(branch_lengths))]

    top_1_pct_nodes = [node for node, length in branch_lengths.items() if length >= threshold]

    # print(len(top_1_pct_nodes))

    return(top_1_pct_nodes)
    
#reassortment rate overall for HA

def compute_rea_rate_simple(tree, clock_rate, ref_seg_len):

    top_1_pct_nodes = top_1(tree)
    reassortment_count = 0
    total_branch_length = 0.0
    rea_events = []  # reassortment events per branches (1 - at least one event, 0 - no events).
    edge_lengths = []
    simple_est = 0
    processed_uncertain = set()

    for k in tree.Objects:

        if (k.is_node() and k.traits["label"] in top_1_pct_nodes) or (k.is_leaf() and k.name in top_1_pct_nodes):
            continue

        if k.traits.get('is_reassorted'):

            reassortment_event = k.traits.get('rea')

            is_uncertain = all([g_str.startswith('_') for g_str in reassortment_event.split('-')])  # Is this 100% uncertain reassortment?

            if not is_uncertain:
                reassortment_count += 1
                rea_events.append(1)
            
            else:
                parent = k.parent
                siblings = [child for child in parent.children if child != k]
                
                if siblings:
                    sibling = siblings[0] #the tree is binary
                    if sibling not in processed_uncertain:
                        reassortment_count += 1
                        rea_events.append(1)
                        edge_length = sibling.length
                        processed_uncertain.add(k)
                    else:
                        continue 
            
        else:
            rea_events.append(0)

        total_branch_length += k.length
        
        if k.length > 1e-7:
            edge_lengths.append(k.length / clock_rate)
            
        elif rea_events[-1] > 0:
            # If reassortment happened on too short of an edge, this can mess up the likelihood function.
            # Replace branch length with (1 / ref_seg_len), e.g., 1 / 1700 for HA (1 substitution).
            edge_lengths.append((1 / ref_seg_len) / clock_rate)
        else:
            edge_lengths.append(0)

    simple_est = (reassortment_count / total_branch_length) * (clock_rate)
    
    np_est = np.array(simple_est)

    linear_constraint = LinearConstraint([[1]], [0])

    num_est = minimize(likelihood_binary, np_est, args=(rea_events, edge_lengths), tol=1e-9,
                       constraints=[linear_constraint])

    if num_est.success:
        mle_est = (num_est.x[0])
    else:
        mle_est = 0

    return(simple_est, mle_est)

#to calculate reassortments on subtrees generated by retrieve_subtrees function

def host_reassortments(trait_trees, trait_order, clock_rate, ref_seg_len):
    
    host_frequencies_simple = {trait: 0 for trait in trait_order}
    host_frequencies_mle = {trait: 0 for trait in trait_order}
    subtree_rates = {trait: [] for trait in trait_order}
	
    for trait, subtrees in trait_trees.items():
        
        total_reassortment_count = 0
        total_branch_length = 0.0

        rea_events = []  # reassortment events per branches (1 - at least one event, 0 - no events).
        edge_lengths = [] # in parallel with rea_events

        processed_uncertain = set()

        for _, subtree in subtrees:
            
            reassortment_count = 0
            branch_length = 0.0
            
            # skipping canine h3n8 since i care about canine h3n2
            if trait == "Canine" and _ == "Equine":
                continue

            ignore_nodes = top_1(subtree) # calculating the top 1% branch length cutoff for each subtree

            for k in subtree.Objects:

                if (k.is_node() and k.traits["label"] in ignore_nodes) or (k.is_leaf() and k.name in ignore_nodes):
                    continue

                if k.traits.get('is_reassorted'):

                    reassortment_event = k.traits.get('rea')

                    is_uncertain = all([g_str.startswith('_') for g_str in reassortment_event.split('-')])  # Is this 100% uncertain reassortment?

                    if not is_uncertain:
                        total_reassortment_count += 1
                        reassortment_count += 1
                        rea_events.append(1)

                    else:
                        parent = k.parent
                        siblings = [child for child in parent.children if child != k]

                        if siblings:
                            sibling = siblings[0] # the tree is binary, so there should be one sibling
                            if sibling not in processed_uncertain:
                                reassortment_count += 1
                                total_reassortment_count += 1
                                rea_events.append(1)
                                edge_length = sibling.length
                                processed_uncertain.add(k)
                            else:
                                continue 

                else:
                    rea_events.append(0)

                total_branch_length += k.length
                branch_length += k.length

                if k.length > 1e-7:
                    edge_lengths.append(k.length / clock_rate)

                elif rea_events[-1] > 0:
                    # If reassortment happened on too short of an edge, this can mess up the likelihood function.
                    # Replace branch length with (1 / ref_seg_len), e.g., 1 / 1700 for HA (1 substitution).
                    edge_lengths.append((1 / ref_seg_len) / clock_rate)
                else:
                    edge_lengths.append(0)
                    
            reassortment_frequency = 0 if branch_length == 0 else (reassortment_count / branch_length) * (clock_rate)
            
            subtree_rates[trait].append(reassortment_frequency)

        # multiplying by clockrate cancels out units to be reassortments per year
        rate = 0 if total_branch_length == 0 else (total_reassortment_count / total_branch_length) * (clock_rate)
        
        host_frequencies_simple[trait] = rate
        
        np_est = np.array(host_frequencies_simple[trait])

        linear_constraint = LinearConstraint([[1]], [0])
        
        num_est = minimize(likelihood_binary, np_est, args=(rea_events, edge_lengths), tol=1e-9,
                           constraints=[linear_constraint])
        
        if num_est.success:
            host_frequencies_mle[trait] = (num_est.x[0])
        else:
            host_frequencies_mle[trait] = 0

    # these host trees have no reassortments 
    # remove = ['Camel', 'Mink', 'Seal', 'Feline']
    # for key in remove:
    #     host_frequencies_simple.pop(key, None)
    #     host_frequencies_mle.pop(key, None)
        
    return(host_frequencies_simple, host_frequencies_mle, subtree_rates)




